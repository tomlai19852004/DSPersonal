https://medium.com/@mzawiejski/compile-time-plugin-architecture-in-go-923455cd2297?source=---
Compile time plugin architecture in GoLet’s say you want to build different distributions of your application and include selected features in some but exclude them from other and still keep a single code base.I’m going to describe a simple, compile time plugin architecture implementation in Go that solves the problem.The architecture consists of the following elements:Plugin initializersInitializers registryInitializers registryThis is a global array of plugin initializers and a code that calls them:main.gopackage mainvar (  // initializers registry  inits = []func(){})func main() {  // call the initializers at startup  for _, i := range inits {    i()  }}Plugin initializerThe initializer resides in a separate .go file and is a func(), added to the initializers registry in init():init_plugin.gopackage mainfunc init() {  initializer := func() {    // Initialize your plugin here  }  // add the plugin initializer to the registry  inits = append(inits, initializer)}This makes the following flow:var declaration in main.go defines the plugins registry arrayinit() in init_plugin.go registers plugin initializer in the registrymain() in main.go ranges over the registry, calling each plugin initializerCompilationGo build tool lets you specify the files to be included in the build. The simplest use of this is to pass a single file, e.g.:go build main.goHowever it’s possible to give multiple files, as long as they all exist in the same directory.The plugin initializer is defined in init_plugin.go so it is possible to decide if the plugin should be included in the executable or not, at the compile time. To include the file, just add it to the go build call:go build main.go init_plugin.goThis will produce a build with the plugin initializer included. You can implement other plugin initializers in other .go files, as long as they exist in the directory of the main.go.Going forwardThe simple architecture can be further extended, e.g. by introducing the application interface and changing the plugin initializer declaration to accept the application interface.main.govar (  inits = []PluginInitializer{})type Application interface {  // application interface details}// PluginInitializer may interact with the Applicationtype PluginInitializer func(Application)func main() {  app := // create an instance of your app implementation here  for _, i := range inits {    i(app)  }}Example — processing data from multiple sourcesThe example application takes and processes data from multiple sources. There are a few editions of the application and each can read data from different set of sources, e.g. standard input, HTTP, Message Queue etc.The application interface is extended with a function returning a data input channel:main.gotype Application interface {  Input() chan&lt;- interface{}}The data sources may be implemented as separate plugins, making the following files:stdin_init.go for standard inputpackage mainfunc init() {  inits = append(inits, func(a Application) {    plugin := stdinPlugin{}    go func() {      for {        a.Input() &lt;- plugin.Read()      }    }()  })}type stdinPlugin struct {}func (p stdinPlugin) Read() interface{} {  // read and return data from stdin}http_init.go for HTTP and mq_init.go for Message Queue.To build an edition supporting Message Queue and HTTP, just pass the relevant files to the build tool:go build main.go http_init.go mq_init.goVariationsThere are other possible variations of the architecture:Keep the plugin initializers in separate packages. Import the packages from a main package file that defines the software edition (e.g. standard_edition.go, extended_edition.go). Pass the edition definition .go file to go build along with main.go.Import the plugin initializers in main.go from a separate package with the initializer files symbolically linked from other source directory. Add or remove the symbolic links before building.Thanks for reading.